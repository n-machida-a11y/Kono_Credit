/**
 * クレジットカード経費精算アプリ (統合版)
 * Ver 4.0 (Mobile UX & Guest Mode Optimization)
 * * 修正内容:
 * 1. ユーザー取得失敗時（未ログイン・未登録）にエラーを返さず「ゲスト」として扱う。
 * 2. 撮影/登録ボタンの統合に伴うフロントエンドへのデータ受け渡しを最適化。
 */

// --- 定数・設定 ---
const SHEETS = {
  RECEIPTS: '領収書',
  DETAILS: '明細',
  ACCOUNTS: '勘定科目マスタ',
  USERS: '使用者マスタ',
  LEARNING: '学習データ',
  CONFIG: '設定',
  CARD_STATEMENT: 'カード明細'
};

const STATUS = {
  DRAFT: '未申請',
  PENDING: '承認待ち',
  APPROVED: '承認',
  REJECTED: '差戻し',
  CHECKED: '確認済み',
  EXPORTED: 'CSV出力済み'
};

const COLS_FINAL = {
  ID: 0, 
  DATE: 1, 
  USE_DATE: 2, 
  USER: 3, 
  STORE: 4, 
  AMOUNT: 5, 
  MEMO_GLOBAL: 6,
  FILE_NAME: 7, 
  FILE_ID: 8, 
  INVOICE: 11,
  ADMIN_CHECK: 12,
  PRESIDENT_CHECK: 13,
  REJECT_COMMENT: 14,
  CARD_NAME: 15
};

const PROPS = PropertiesService.getScriptProperties();
const GEMINI_API_KEY = PROPS.getProperty('GEMINI_API_KEY');
const FOLDER_ID = PROPS.getProperty('RECEIPT_FOLDER_ID');

function doGet(e) {
  return HtmlService.createTemplateFromFile('Index')
    .evaluate()
    .setTitle('クレジット精算アプリ')
    .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

/**
 * ユーザー情報を取得
 * 修正：エラー時にポップアップを出さないよう、デフォルト値を返す
 */
function getCurrentUser(email) {
  try {
    const activeUser = Session.getActiveUser().getEmail();
    const targetEmail = email || activeUser;
    
    // ゲスト用デフォルトオブジェクト
    const guestUser = { 
      name: 'ゲスト', 
      email: targetEmail || 'unknown', 
      role: '一般', 
      card: '', 
      dept: '', 
      canFix: false 
    };

    if (!targetEmail) return guestUser;
    
    const sheet = getSheet(SHEETS.USERS);
    const data = sheet.getDataRange().getValues();
    if (data.length <= 1) return guestUser;
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const masterEmail = String(row[3] || "").trim().toLowerCase();
      if (masterEmail === targetEmail.toLowerCase()) {
        return { 
          name: String(row[0] || "No Name"), 
          email: targetEmail, 
          role: String(row[1] || "一般"), 
          card: String(row[2] || ""), 
          dept: String(row[4] || ""), // E列: 部門コード
          canFix: true 
        };
      }
    }
    return guestUser;
  } catch (e) {
    console.error("User Auth Error: " + e.message);
    return { name: 'システムエラー', email: '', role: 'Error', error: e.message };
  }
}

function getMasters() {
  try {
    const sheet = getSheet(SHEETS.ACCOUNTS);
    const data = sheet.getDataRange().getValues();
    const accounts = data.slice(1).map(r => String(r[1] || '')).filter(Boolean);
    return { accounts: accounts };
  } catch (e) {
    return { accounts: [] };
  }
}

// --- 学習機能 ---
function updateLearningData(key, value, type = 'CATEGORY') {
  if(!key || !value) return;
  const sheet = getSheet(SHEETS.LEARNING);
  sheet.appendRow([key, value, new Date(), type]);
}

function findLearnedData(keyword, type = 'CATEGORY') {
  const sheet = getSheet(SHEETS.LEARNING);
  if (sheet.getLastRow() < 2) return null;
  const data = sheet.getDataRange().getValues();
  for(let i=data.length-1; i>=1; i--) {
    const rowKey = String(data[i][0]);
    const rowValue = String(data[i][1]);
    const rowType = String(data[i][3] || 'CATEGORY');
    if (rowType === type) {
      if (type === 'STORE' && (keyword === rowKey || keyword.startsWith(rowKey))) return rowValue;
      if (type === 'CATEGORY' && keyword.includes(rowKey)) return rowValue;
    }
  }
  return null;
}

function findCategoryInMaster(keyword) {
  if (!keyword) return null;
  const sheet = getSheet(SHEETS.ACCOUNTS);
  const data = sheet.getDataRange().getValues();
  for (let i = 1; i < data.length; i++) {
    const account = String(data[i][1] || '').trim();
    if (account && keyword.includes(account)) return account;
  }
  return null;
}

// --- メイン処理 ---
function uploadAndAnalyzeAndDraft(fileData) {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(30000)) throw new Error('サーバーが混み合っています。');
  try {
    const currentUser = getCurrentUser(); 
    const cardName = currentUser.card || '';
    let fileId = 'NO_FILE';
    try {
      const blob = Utilities.newBlob(Utilities.base64Decode(fileData.base64), fileData.mimeType, fileData.fileName);
      const folder = FOLDER_ID ? DriveApp.getFolderById(FOLDER_ID) : DriveApp.getRootFolder();
      const file = folder.createFile(blob);
      file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
      fileId = file.getId();
    } catch(e) { console.error('File Save Error', e); }
    
    const aiResult = callGeminiApi(fileData.base64, fileData.mimeType);
    let finalStoreName = aiResult.store_name || '';
    const learnedStoreName = findLearnedData(finalStoreName, 'STORE');
    if (learnedStoreName) finalStoreName = learnedStoreName;
    
    let predictedCategory = aiResult.category;
    if (!predictedCategory) predictedCategory = findLearnedData(aiResult.item_name || '', 'CATEGORY') || findLearnedData(finalStoreName, 'CATEGORY') || findCategoryInMaster(aiResult.item_name || '') || findCategoryInMaster(finalStoreName);
    if (!predictedCategory) predictedCategory = '消耗品費';
    
    const rSheet = getSheet(SHEETS.RECEIPTS), dSheet = getSheet(SHEETS.DETAILS);
    const regId = Utilities.getUuid(), now = new Date();
    const rRow = new Array(COLS_FINAL.CARD_NAME + 1).fill(''); 
    rRow[COLS_FINAL.ID] = regId;
    rRow[COLS_FINAL.DATE] = now;
    rRow[COLS_FINAL.USE_DATE] = aiResult.use_date || now;
    rRow[COLS_FINAL.USER] = fileData.userName;
    rRow[COLS_FINAL.STORE] = finalStoreName;
    rRow[COLS_FINAL.AMOUNT] = aiResult.total_amount || 0;
    rRow[COLS_FINAL.MEMO_GLOBAL] = aiResult.summary_text || '';
    rRow[COLS_FINAL.FILE_NAME] = fileData.fileName;
    rRow[COLS_FINAL.FILE_ID] = fileId;
    rRow[COLS_FINAL.INVOICE] = aiResult.has_invoice ? 'あり' : 'なし';
    rRow[COLS_FINAL.ADMIN_CHECK] = '未チェック'; 
    rRow[COLS_FINAL.PRESIDENT_CHECK] = STATUS.DRAFT;
    rRow[COLS_FINAL.CARD_NAME] = cardName;
    rSheet.appendRow(rRow);
    
    const total = Number(aiResult.total_amount) || 0;
    const net = Math.round(total / 1.1), tax = total - net;
    dSheet.appendRow([Utilities.getUuid(), regId, predictedCategory, aiResult.item_name || '品代', total, aiResult.client || '', aiResult.participants || '', net, tax, '']);
    
    return { success: true, id: regId, fileId: fileId, store: finalStoreName, amount: total, cardName: cardName };
  } catch(e) { throw new Error(e.message); } finally { lock.releaseLock(); }
}

function updateApplication(formData) {
  const rSheet = getSheet(SHEETS.RECEIPTS), dSheet = getSheet(SHEETS.DETAILS);
  const data = rSheet.getDataRange().getValues();
  let rowIndex = -1;
  for(let i=1; i<data.length; i++) if(String(data[i][COLS_FINAL.ID]) === String(formData.id)) { rowIndex = i + 1; break; }
  if(rowIndex === -1) throw new Error('データなし');
  
  const currentRow = data[rowIndex - 1];
  const currentStore = String(currentRow[COLS_FINAL.STORE] || ''), newStore = String(formData.storeName || ''); 
  if (currentStore && newStore && currentStore !== newStore) updateLearningData(currentStore, newStore, 'STORE');
  
  rSheet.getRange(rowIndex, COLS_FINAL.USE_DATE + 1).setValue(formData.useDate);
  rSheet.getRange(rowIndex, COLS_FINAL.STORE + 1).setValue(formData.storeName);
  rSheet.getRange(rowIndex, COLS_FINAL.AMOUNT + 1).setValue(Number(formData.totalAmount));
  rSheet.getRange(rowIndex, COLS_FINAL.INVOICE + 1).setValue(formData.hasInvoice ? 'あり':'なし');
  rSheet.getRange(rowIndex, COLS_FINAL.MEMO_GLOBAL + 1).setValue(formData.globalMemo || '');
  
  if(formData.items) {
      const dData = dSheet.getDataRange().getValues();
      for(let i=dData.length-1; i>=1; i--) if(String(dData[i][1]) === String(formData.id)) dSheet.deleteRow(i+1);
      const newRows = formData.items.map(it => {
        updateLearningData(it.itemName, it.category, 'CATEGORY');
        const price = Number(it.total_price), net = Math.round(price / 1.1), tax = price - net;
        return [Utilities.getUuid(), formData.id, it.category, it.itemName, price, it.client || '', it.participants || '', net, tax, it.memo || ''];
      });
      if (newRows.length > 0) dSheet.getRange(dSheet.getLastRow() + 1, 1, newRows.length, newRows[0].length).setValues(newRows);
  }
  return { success: true };
}

function getDataForCSV(ids) {
  const ss = SpreadsheetApp.getActiveSpreadsheet(), rSheet = getSheet(SHEETS.RECEIPTS), dSheet = getSheet(SHEETS.DETAILS);
  
  const aSheet = getSheet(SHEETS.ACCOUNTS);
  const aData = aSheet.getDataRange().getValues(), accountCodeMap = {};
  for(let i=1; i<aData.length; i++) {
    const code = String(aData[i][0] || '').trim();
    const name = String(aData[i][1] || '').trim();
    if(name) accountCodeMap[name] = code;
  }

  const uSheet = getSheet(SHEETS.USERS);
  const uData = uSheet.getDataRange().getValues(), userDeptMap = {};
  for(let i=1; i<uData.length; i++) {
    const uName = String(uData[i][0] || '').trim();
    const uDept = String(uData[i][4] || '').trim(); 
    if(uName) userDeptMap[uName] = uDept;
  }

  const rData = rSheet.getRange(2, 1, rSheet.getLastRow() - 1, COLS_FINAL.CARD_NAME + 1).getValues();
  const dData = dSheet.getDataRange().getLastRow() > 1 ? dSheet.getDataRange().getValues().slice(1) : [];
  const detailMap = {};
  dData.forEach(d => {
    const pid = String(d[1]);
    if(!detailMap[pid]) detailMap[pid] = [];
    detailMap[pid].push({ category: d[2], item: d[3], amount: d[4] });
  });

  const targets = rData.filter(row => ids.includes(String(row[COLS_FINAL.ID])));
  const csvRows = [['部門コード（借方）', '科目コード', '勘定科目（借方）', '金額（借方）', '部門コード（貸方）', '勘定科目（貸方）', '金額（貸方）', '摘要']];
  const fmtNum = n => Number(n).toLocaleString(), fmtDate = d => { const dt = new Date(d); return (dt.getMonth()+1) + '/' + dt.getDate(); };

  targets.forEach(row => {
    const card = row[COLS_FINAL.CARD_NAME] || 'JCB', creditAcc = '未払費用 ' + card, date = fmtDate(row[COLS_FINAL.USE_DATE]), store = row[COLS_FINAL.STORE];
    const user = String(row[COLS_FINAL.USER] || '').trim();
    const deptCode = userDeptMap[user] || ''; 
    const details = detailMap[String(row[COLS_FINAL.ID])] || [];

    if (details.length === 0) {
      const amt = Number(row[COLS_FINAL.AMOUNT]);
      csvRows.push([deptCode, '', '使途不明金', fmtNum(amt), '', creditAcc, fmtNum(amt), card + ' ' + store + ' ' + date]);
    } else {
      details.forEach(d => {
        const accCode = accountCodeMap[d.category] || '';
        csvRows.push([deptCode, accCode, d.category, fmtNum(d.amount), '', creditAcc, fmtNum(d.amount), card + ' ' + store + ' ' + d.item + ' ' + date]);
      });
    }
  });
  return csvRows;
}

function markAsExported(ids) {
  const sheet = getSheet(SHEETS.RECEIPTS), data = sheet.getDataRange().getValues();
  ids.forEach(id => {
    for(let i=1; i<data.length; i++) if(String(data[i][COLS_FINAL.ID]) === String(id)) sheet.getRange(i+1, COLS_FINAL.ADMIN_CHECK + 1).setValue(STATUS.EXPORTED);
  });
  return { success: true };
}

function getSheet(name) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(name);
  if (!sheet) sheet = ss.insertSheet(name);
  return sheet;
}
function formatDate(date) {
  if (!date) return '';
  if (typeof date === 'string') return date;
  return Utilities.formatDate(new Date(date), Session.getScriptTimeZone(), 'yyyy-MM-dd');
}
function callGeminiApi(base64, mimeType) {
  if (!GEMINI_API_KEY) return {};
  const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=' + GEMINI_API_KEY;
  const prompt = "領収書画像解析。JSON出力。項目:use_date(YYYY-MM-DD),store_name,total_amount(数値),item_name,category,has_invoice(bool),client,participants,summary_text";
  const payload = { contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: mimeType, data: base64 } }] }] };
  try {
    const res = UrlFetchApp.fetch(url, { method: 'post', contentType: 'application/json', payload: JSON.stringify(payload), muteHttpExceptions: true });
    const json = JSON.parse(res.getContentText());
    if (!json.candidates) return {};
    const text = json.candidates[0].content.parts[0].text;
    return JSON.parse(text.replace(/```json|```/g, '').trim());
  } catch (e) { return {}; }
}
function getHistoryData(filter) {
  try {
    const user = getCurrentUser(), rSheet = getSheet(SHEETS.RECEIPTS), dSheet = getSheet(SHEETS.DETAILS);
    if (rSheet.getLastRow() <= 1) return [];
    const data = rSheet.getRange(2, 1, rSheet.getLastRow() - 1, COLS_FINAL.CARD_NAME + 1).getValues();
    const dupMap = {};
    data.forEach(row => {
      const k = formatDate(row[COLS_FINAL.USE_DATE]) + "_" + String(row[COLS_FINAL.STORE]).trim() + "_" + Number(row[COLS_FINAL.AMOUNT]);
      dupMap[k] = (dupMap[k] || 0) + 1;
    });
    const dData = dSheet.getDataRange().getLastRow() > 1 ? dSheet.getDataRange().getValues().slice(1) : [];
    const detailMap = {};
    dData.forEach(d => {
      const pid = String(d[1]);
      if(!detailMap[pid]) detailMap[pid] = [];
      detailMap[pid].push({ category: d[2], item: d[3], amount: d[4] });
    });
    let rows = data.map(row => {
      const mStatus = row[COLS_FINAL.ADMIN_CHECK], nStatus = row[COLS_FINAL.PRESIDENT_CHECK];
      let displayStatus = 'draft';
      if (nStatus === STATUS.PENDING) displayStatus = 'pending';
      else if (nStatus === STATUS.APPROVED) {
        if (mStatus === STATUS.EXPORTED) displayStatus = 'exported';
        else if (mStatus === STATUS.CHECKED) displayStatus = 'checked';
        else displayStatus = 'approved';
      }
      else if (nStatus === STATUS.REJECTED) displayStatus = 'rejected';
      const key = formatDate(row[COLS_FINAL.USE_DATE]) + "_" + String(row[COLS_FINAL.STORE]).trim() + "_" + Number(row[COLS_FINAL.AMOUNT]);
      return {
        id: row[COLS_FINAL.ID], date: formatDate(row[COLS_FINAL.USE_DATE]), user: row[COLS_FINAL.USER], store: row[COLS_FINAL.STORE], amount: row[COLS_FINAL.AMOUNT],
        status: displayStatus, rawStatusM: mStatus, items: detailMap[String(row[COLS_FINAL.ID])] || [], fileId: row[COLS_FINAL.FILE_ID], isDuplicate: (dupMap[key] > 1)
      };
    });
    if (filter.view === 'history' && user.role !== '経理' && user.role !== '管理者' && user.role !== '社長') rows = rows.filter(r => r.user === user.name);
    else if (filter.view === 'president') rows = rows.filter(r => r.status === 'pending');
    else if (filter.view === 'admin') rows = rows.filter(r => r.status === 'approved' || r.status === 'checked');
    return rows.reverse();
  } catch (e) { return []; }
}
function getSingleApplicationData(id) {
    try {
        const rSheet = getSheet(SHEETS.RECEIPTS), dSheet = getSheet(SHEETS.DETAILS);
        const data = rSheet.getRange(2, 1, rSheet.getLastRow() - 1, COLS_FINAL.CARD_NAME + 1).getValues();
        const rRow = data.find(row => String(row[COLS_FINAL.ID]) === String(id));
        if (!rRow) return null;
        const dData = dSheet.getDataRange().getLastRow() > 1 ? dSheet.getDataRange().getValues().slice(1) : [];
        const dRows = dData.filter(d => String(d[1]) === String(id));
        return {
            id: rRow[COLS_FINAL.ID], date: formatDate(rRow[COLS_FINAL.USE_DATE]), user: rRow[COLS_FINAL.USER], store: rRow[COLS_FINAL.STORE],
            amount: rRow[COLS_FINAL.AMOUNT], hasInvoice: rRow[COLS_FINAL.INVOICE] === 'あり', fileId: rRow[COLS_FINAL.FILE_ID],
            globalMemo: rRow[COLS_FINAL.MEMO_GLOBAL] || '', cardName: rRow[COLS_FINAL.CARD_NAME] || '',
            items: dRows.map(d => ({ id: d[0], category: d[2], item: d[3], amount: d[4], net: d[7], tax: d[8], memo: d[9] }))
        };
    } catch (e) { return null; }
}
function submitBulkApplications(ids) { return updateStatusBulk(ids, STATUS.PENDING, 'president'); }
function approveBulk(ids) { return updateStatusBulk(ids, STATUS.APPROVED, 'president'); }
function checkBulk(ids) { return updateStatusBulk(ids, STATUS.CHECKED, 'admin'); }
function updateStatusBulk(ids, newStatus, type) {
  const sheet = getSheet(SHEETS.RECEIPTS), data = sheet.getDataRange().getValues();
  const col = type === 'president' ? COLS_FINAL.PRESIDENT_CHECK : COLS_FINAL.ADMIN_CHECK;
  ids.forEach(id => {
    for(let i=1; i<data.length; i++) if(String(data[i][COLS_FINAL.ID]) === String(id)) {
      sheet.getRange(i+1, col + 1).setValue(newStatus);
      if(newStatus === STATUS.PENDING) sheet.getRange(i+1, COLS_FINAL.ADMIN_CHECK + 1).setValue('未チェック');
    }
  });
  return { success: true };
}
function deleteApplication(id) {
  const rSheet = getSheet(SHEETS.RECEIPTS), dSheet = getSheet(SHEETS.DETAILS), rData = rSheet.getDataRange().getValues();
  for(let i=rData.length-1; i>=1; i--) if(String(rData[i][COLS_FINAL.ID]) === String(id)) rSheet.deleteRow(i+1);
  const dData = dSheet.getDataRange().getValues();
  for(let i=dData.length-1; i>=1; i--) if(String(dData[i][1]) === String(id)) dSheet.deleteRow(i+1);
  return { success: true };
}
function rejectBulkWithComment(ids, comment) {
    const rSheet = getSheet(SHEETS.RECEIPTS), data = rSheet.getDataRange().getValues();
    ids.forEach(id => {
        for(let i=1; i<data.length; i++) if(String(data[i][COLS_FINAL.ID]) === String(id)) {
            rSheet.getRange(i+1, COLS_FINAL.PRESIDENT_CHECK + 1).setValue(STATUS.REJECTED);
            rSheet.getRange(i+1, COLS_FINAL.REJECT_COMMENT + 1).setValue(comment);
        }
    });
    return { success: true };
}
