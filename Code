/**
 * クレジットカード経費精算アプリ (統合版)
 * Ver 2.7 (Detail Columns Fix)
 * * 修正内容:
 * 1. 複数明細行の保存に対応するよう updateApplication を修正。
 * 2. 領収書データ (R-Sheet) に GlobalMemo の列を追加・更新。
 * 3. 社長向けの単一データ取得機能 (getSingleApplicationData) を追加。
 * 4. 差し戻しコメント機能 (REJECT_COMMENT列) を追加し、差戻しデータを修正可能にした。
 * 5. 【重要修正】領収書シートの列定義を、実態（トークン列の存在）に合わせて修正。
 */

// --- 定数・設定 ---
const SHEETS = {
  RECEIPTS: '領収書',
  DETAILS: '明細',
  ACCOUNTS: '勘定科目マスタ',
  USERS: '使用者マスタ',
  LEARNING: '学習データ',
  CONFIG: '設定'
};

// ステータス定義
const STATUS = {
  DRAFT: '未申請',
  PENDING: '承認待ち',
  APPROVED: '承認',
  REJECTED: '差戻し',
  CHECKED: 'チェック済み'
};

// 領収書シートの最終的な列定義 (列9, 10に入力/出力トークン列が存在することを前提)
// 0:登録ID, 1:登録日時, 2:利用日, 3:使用者, 4:支払先, 5:合計金額, 6:メモ, 7:ファイル名, 8:ファイルID, 9:入力トークン, 10:出力トークン
// 11:インボイス, 12:管理チェック, 13:最終承認, 14:差戻しコメント
const COLS_FINAL = {
  ID: 0, 
  DATE: 1, 
  USE_DATE: 2, 
  USER: 3, 
  STORE: 4, 
  AMOUNT: 5, 
  MEMO_GLOBAL: 6, // メモ
  FILE_NAME: 7, 
  FILE_ID: 8, 
  // 列9, 10 はトークン列としてスキップ
  INVOICE: 11, // インボイス番号
  ADMIN_CHECK: 12, // 管理チェック
  PRESIDENT_CHECK: 13, // 最終承認
  REJECT_COMMENT: 14 // ★差戻しコメントを列14に追加
};


const PROPS = PropertiesService.getScriptProperties();
const GEMINI_API_KEY = PROPS.getProperty('GEMINI_API_KEY');
const FOLDER_ID = PROPS.getProperty('RECEIPT_FOLDER_ID');

/**
 * HTMLを表示
 */
function doGet(e) {
  return HtmlService.createTemplateFromFile('index')
    .evaluate()
    .setTitle('クレジット精算アプリ')
    .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

/**
 * ユーザー情報を取得
 */
function getCurrentUser(email) {
  try {
    const activeUser = Session.getActiveUser().getEmail();
    const targetEmail = email || activeUser;

    if (!targetEmail) {
      return { name: 'ゲスト(Email不明)', email: 'unknown', role: 'Guest', error: 'EMAIL_EMPTY' };
    }

    const sheet = getSheet(SHEETS.USERS);
    const data = sheet.getDataRange().getValues();
    
    if (data.length <= 1) {
      return { name: 'マスタ設定エラー', email: targetEmail, role: 'Guest', error: 'NO_MASTER_DATA' };
    }

    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const masterEmail = String(row[3] || "").trim();
      const masterName = String(row[0] || "No Name");
      
      if (masterEmail.toLowerCase() === targetEmail.toLowerCase()) {
        return {
          name: masterName,
          email: masterEmail,
          role: String(row[1] || "一般"),
          card: String(row[2] || ""),
          canFix: true
        };
      }
    }
    
    return { name: '未登録ユーザー', email: targetEmail, role: 'Guest', canFix: false, error: 'NOT_REGISTERED' };

  } catch (e) {
    console.error(`[Auth] Error: ${e.message}`);
    return { name: 'システムエラー', email: 'error', role: 'Error', error: e.message };
  }
}

/**
 * マスタデータ取得
 */
function getMasters() {
  try {
    const sheet = getSheet(SHEETS.ACCOUNTS);
    const accounts = sheet.getDataRange().getValues().slice(1).map(r => r[0]).filter(String);
    return { accounts: accounts };
  } catch (e) {
    console.error("getMasters Error", e);
    return { accounts: [] };
  }
}

/**
 * ファイルアップロード & AI解析 & 下書き保存
 */
function uploadAndAnalyzeAndDraft(fileData) {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(30000)) throw new Error('サーバーが混み合っています。再試行してください。');

  try {
    // 1. ファイル保存
    let fileId = 'NO_FILE';
    try {
      const blob = Utilities.newBlob(Utilities.base64Decode(fileData.base64), fileData.mimeType, fileData.fileName);
      const folder = FOLDER_ID ? DriveApp.getFolderById(FOLDER_ID) : DriveApp.getRootFolder();
      const file = folder.createFile(blob);
      file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
      fileId = file.getId();
    } catch(e) {
      console.error('File Save Error', e);
    }

    // 2. AI解析
    const aiResult = callGeminiApi(fileData.base64, fileData.mimeType);
    
    // 3. 学習データ補正
    let predictedCategory = aiResult.category;
    if (!predictedCategory) predictedCategory = predictCategoryByItem(aiResult.item_name || '') || predictCategoryByItem(aiResult.store_name || '');

    // 4. DB保存 (下書き)
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    const regId = Utilities.getUuid();
    const now = new Date();
    
    // 親データ
    // 配列のサイズは最終列のインデックス+1
    const rRow = new Array(COLS_FINAL.REJECT_COMMENT + 1).fill(''); 
    rRow[COLS_FINAL.ID] = regId;
    rRow[COLS_FINAL.DATE] = now;
    rRow[COLS_FINAL.USE_DATE] = aiResult.use_date || now;
    rRow[COLS_FINAL.USER] = fileData.userName;
    rRow[COLS_FINAL.STORE] = aiResult.store_name || '';
    rRow[COLS_FINAL.AMOUNT] = aiResult.total_amount || 0;
    rRow[COLS_FINAL.MEMO_GLOBAL] = aiResult.summary_text || '';
    rRow[COLS_FINAL.FILE_NAME] = fileData.fileName;
    rRow[COLS_FINAL.FILE_ID] = fileId;
    rRow[COLS_FINAL.INVOICE] = aiResult.has_invoice ? 'あり' : 'なし';
    rRow[COLS_FINAL.ADMIN_CHECK] = STATUS.DRAFT; 
    rRow[COLS_FINAL.PRESIDENT_CHECK] = STATUS.DRAFT;
    rSheet.appendRow(rRow);

    // 明細データ (1明細のみ)
    // 明細ID(0), 登録ID(1), 勘定科目(2), 項目(3), 明細金額(4), 取引先(5), 参加人数(6), 税抜合計(7), 消費税(8), メモ(9)
    const total = aiResult.total_amount || 0;
    const tax = total ? (total - Math.round(total/1.1)) : 0;
    const dRow = [
      Utilities.getUuid(),  // 0: 明細ID
      regId,                // 1: 登録ID
      predictedCategory || '消耗品費', // 2: 勘定科目
      aiResult.item_name || '品代',    // 3: 項目
      total,                // 4: 明細金額（税込）
      aiResult.client || '',       // 5: 取引先
      aiResult.participants || '', // 6: 参加人数
      total - tax,          // 7: 税抜合計
      tax,                  // 8: 消費税
      ''                    // 9: メモ
    ];
    dSheet.appendRow(dRow);

    return { 
      success: true, 
      id: regId, 
      store: aiResult.store_name || '', 
      amount: total, 
      date: formatDate(aiResult.use_date), 
      fileId: fileId,
      hasInvoice: aiResult.has_invoice,
      globalMemo: aiResult.summary_text || '',
      items: [{
        category: predictedCategory || '消耗品費',
        item: aiResult.item_name || '品代',
        amount: total,
        client: aiResult.client || '',
        participants: aiResult.participants || '',
        memo: ''
      }]
    };

  } catch(e) {
    throw new Error('処理エラー: ' + e.message);
  } finally {
    lock.releaseLock();
  }
}

/**
 * 履歴データ取得
 */
function getHistoryData(filter) {
  try {
    const user = getCurrentUser();
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const dSheet = ss.getSheetByName(SHEETS.DETAILS);
    
    if (sheet.getLastRow() <= 1) return [];

    // データ範囲を修正後の列数に合わせて調整 (最大列インデックス + 1)
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, COLS_FINAL.REJECT_COMMENT + 1).getValues();
    const dData = dSheet.getDataRange().getValues().slice(1);

    const detailMap = {};
    dData.forEach(d => {
      // d[1]が登録ID
      const pid = String(d[1]);
      if(!detailMap[pid]) detailMap[pid] = [];
      // 0:ID, 1:PID, 2:Category, 3:Item, 4:Amount, 5:Client, 6:Participants, 7:Net, 8:Tax, 9:Memo
      detailMap[pid].push({ 
        id: d[0], 
        category: d[2], 
        item: d[3], 
        amount: d[4],
        client: d[5],
        participants: d[6],
        memo: d[9]
      });
    });

    let rows = data.map(row => {
      const mStatus = row[COLS_FINAL.ADMIN_CHECK];
      const nStatus = row[COLS_FINAL.PRESIDENT_CHECK];
      let displayStatus = 'unknown';
      if (nStatus === STATUS.DRAFT) displayStatus = 'draft';
      else if (nStatus === STATUS.PENDING) displayStatus = 'pending';
      else if (nStatus === STATUS.APPROVED) {
          if (mStatus === STATUS.CHECKED) displayStatus = 'checked';
          else displayStatus = 'approved';
      }
      else if (nStatus === STATUS.REJECTED) displayStatus = 'rejected';

      return {
        id: row[COLS_FINAL.ID],
        date: formatDate(row[COLS_FINAL.USE_DATE]),
        user: row[COLS_FINAL.USER],
        store: row[COLS_FINAL.STORE],
        amount: row[COLS_FINAL.AMOUNT],
        status: displayStatus,
        rawStatusN: nStatus,
        rawStatusM: mStatus,
        hasInvoice: row[COLS_FINAL.INVOICE] === 'あり',
        items: detailMap[String(row[COLS_FINAL.ID])] || [],
        fileId: row[COLS_FINAL.FILE_ID],
        globalMemo: row[COLS_FINAL.MEMO_GLOBAL] || '',
        rejectComment: row[COLS_FINAL.REJECT_COMMENT] || '' // ★差し戻しコメントを取得
      };
    });

    // フィルタリング
    if (filter.view === 'history') {
      if (user.role !== '経理' && user.role !== '管理者' && user.role !== '社長') {
        rows = rows.filter(r => r.user === user.name);
      }
    } else if (filter.view === 'president') {
      rows = rows.filter(r => r.rawStatusN === STATUS.PENDING);
    } else if (filter.view === 'admin') {
      rows = rows.filter(r => r.rawStatusN === STATUS.APPROVED && r.rawStatusM !== STATUS.CHECKED);
    }

    return rows.reverse();
  } catch (e) {
    console.error("getHistoryData Error", e);
    return [];
  }
}

/**
 * 単一の申請データをIDから取得するヘルパー関数
 */
function getSingleApplicationData(id) {
    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const sheet = ss.getSheetByName(SHEETS.RECEIPTS);
        const dSheet = ss.getSheetByName(SHEETS.DETAILS);
        
        const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, COLS_FINAL.REJECT_COMMENT + 1).getValues();
        const dData = dSheet.getDataRange().getValues().slice(1);

        const rRow = data.find(row => String(row[COLS_FINAL.ID]) === String(id));
        if (!rRow) return null;

        const dRows = dData.filter(d => String(d[1]) === String(id));
        
        // rRowからデータオブジェクトを構築 (getHistoryDataと同じ形式)
        const item = {
            id: rRow[COLS_FINAL.ID],
            date: formatDate(rRow[COLS_FINAL.USE_DATE]),
            user: rRow[COLS_FINAL.USER],
            store: rRow[COLS_FINAL.STORE],
            amount: rRow[COLS_FINAL.AMOUNT],
            hasInvoice: rRow[COLS_FINAL.INVOICE] === 'あり',
            fileId: rRow[COLS_FINAL.FILE_ID],
            globalMemo: rRow[COLS_FINAL.MEMO_GLOBAL] || '',
            rejectComment: rRow[COLS_FINAL.REJECT_COMMENT] || '', // ★差し戻しコメントを取得
            items: dRows.map(d => ({
                id: d[0], 
                category: d[2], 
                item: d[3], 
                amount: d[4],
                client: d[5],
                participants: d[6],
                memo: d[9]
            }))
        };
        return item;

    } catch (e) {
        console.error("getSingleApplicationData Error", e);
        return null;
    }
}


// --- 以下、一括申請・承認などのアクション ---
function submitBulkApplications(ids) { return updateStatusBulk(ids, STATUS.PENDING, 'president'); }
function rejectBulk(ids) { return updateStatusBulk(ids, STATUS.REJECTED, 'president'); }
function checkBulk(ids) { return updateStatusBulk(ids, STATUS.CHECKED, 'admin'); }

/**
 * コメント付きで一括差戻しを行う
 */
function rejectBulkWithComment(ids, comment) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEETS.RECEIPTS);
    const data = sheet.getDataRange().getValues();
    
    ids.forEach(id => {
        for(let i=1; i<data.length; i++) {
            if(String(data[i][COLS_FINAL.ID]) === String(id)) {
                // ステータスを差戻しに設定
                sheet.getRange(i+1, COLS_FINAL.PRESIDENT_CHECK + 1).setValue(STATUS.REJECTED);
                // コメントを保存
                sheet.getRange(i+1, COLS_FINAL.REJECT_COMMENT + 1).setValue(comment);
                break;
            }
        }
    });
    return { success: true };
}

function approveBulk(ids) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEETS.RECEIPTS);
  const data = sheet.getDataRange().getValues();
  ids.forEach(id => {
    for(let i=1; i<data.length; i++) {
      if(String(data[i][COLS_FINAL.ID]) === String(id)) {
        sheet.getRange(i+1, COLS_FINAL.PRESIDENT_CHECK + 1).setValue(STATUS.APPROVED);
        sheet.getRange(i+1, COLS_FINAL.ADMIN_CHECK + 1).setValue('未チェック');
        // 承認時はコメントをクリア
        sheet.getRange(i+1, COLS_FINAL.REJECT_COMMENT + 1).setValue(''); 
        break;
      }
    }
  });
  return {success: true};
}

function updateStatusBulk(ids, newStatus, targetColType) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(SHEETS.RECEIPTS);
  const data = sheet.getDataRange().getValues();
  const targetCol = targetColType === 'president' ? COLS_FINAL.PRESIDENT_CHECK : COLS_FINAL.ADMIN_CHECK;
  ids.forEach(id => {
    for(let i=1; i<data.length; i++) {
      if(String(data[i][COLS_FINAL.ID]) === String(id)) {
        sheet.getRange(i+1, targetCol + 1).setValue(newStatus);
        
        if(newStatus === STATUS.PENDING) {
            sheet.getRange(i+1, COLS_FINAL.ADMIN_CHECK + 1).setValue('未チェック');
        }
        // ステータスが変更されたらコメントをクリア (再申請時など)
        if (newStatus !== STATUS.REJECTED) {
             sheet.getRange(i+1, COLS_FINAL.REJECT_COMMENT + 1).setValue(''); 
        }
        break;
      }
    }
  });
  return { success: true };
}

/**
 * 経費申請データを更新（複数明細対応）
 */
function updateApplication(formData) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
  const dSheet = ss.getSheetByName(SHEETS.DETAILS);
  const data = rSheet.getDataRange().getValues();
  let rowIndex = -1;
  for(let i=1; i<data.length; i++) {
    if(String(data[i][COLS_FINAL.ID]) === String(formData.id)) { rowIndex = i + 1; break; }
  }
  if(rowIndex === -1) throw new Error('データが見つかりません');

  // 1. 親データ (領収書シート) の更新
  rSheet.getRange(rowIndex, COLS_FINAL.USE_DATE + 1).setValue(formData.useDate);
  rSheet.getRange(rowIndex, COLS_FINAL.STORE + 1).setValue(formData.storeName);
  rSheet.getRange(rowIndex, COLS_FINAL.AMOUNT + 1).setValue(Number(formData.totalAmount));
  rSheet.getRange(rowIndex, COLS_FINAL.INVOICE + 1).setValue(formData.hasInvoice ? 'あり':'なし');
  rSheet.getRange(rowIndex, COLS_FINAL.MEMO_GLOBAL + 1).setValue(formData.globalMemo || ''); 
  
  // 修正データが保存された場合、ステータスを「未申請」に戻し、コメントをクリアする
  rSheet.getRange(rowIndex, COLS_FINAL.PRESIDENT_CHECK + 1).setValue(STATUS.DRAFT);
  rSheet.getRange(rowIndex, COLS_FINAL.ADMIN_CHECK + 1).setValue(STATUS.DRAFT);
  rSheet.getRange(rowIndex, COLS_FINAL.REJECT_COMMENT + 1).setValue(''); 


  // 2. 明細更新 (全削除して挿入)
  if(formData.items && formData.items.length > 0) {
      // 既存の明細行を削除
      const dData = dSheet.getDataRange().getValues();
      // 後ろから削除することでインデックスのズレを防ぐ
      for(let i=dData.length-1; i>=1; i--) {
        if(String(dData[i][1]) === String(formData.id)) dSheet.deleteRow(i+1);
      }
      
      // 新しい明細行を挿入
      formData.items.forEach(item => {
        const price = Number(item.total_price);
        // 税額計算 (10%固定として処理 - クライアント側で計算されたものを再計算)
        const tax = Math.round(price - (price/1.1));
        
        // 0:ID, 1:PID, 2:Category, 3:Item, 4:Amount, 5:Client, 6:Participants, 7:Net, 8:Tax, 9:Memo
        dSheet.appendRow([
          Utilities.getUuid(), 
          formData.id, 
          item.category, 
          item.itemName, 
          price, 
          item.client || '',
          item.participants || '',
          price - tax,
          tax, 
          item.memo || ''
        ]);

        // 学習データの更新
        updateLearningData(item.itemName, item.category);
      });
  }

  return { success: true };
}

function deleteApplication(id) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const rSheet = ss.getSheetByName(SHEETS.RECEIPTS);
  const dSheet = ss.getSheetByName(SHEETS.DETAILS);
  const rData = rSheet.getDataRange().getValues();
  for(let i=rData.length-1; i>=1; i--) if(String(rData[i][COLS_FINAL.ID]) === String(id)) rSheet.deleteRow(i+1);
  const dData = dSheet.getDataRange().getValues();
  for(let i=dData.length-1; i>=1; i--) if(String(dData[i][1]) === String(id)) dSheet.deleteRow(i+1);
  return { success: true };
}

// --- Utils ---
function getSheet(name) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName(name);
  if (!sheet) sheet = ss.insertSheet(name);
  return sheet;
}

function formatDate(date) {
  if (!date) return '';
  return Utilities.formatDate(new Date(date), Session.getScriptTimeZone(), 'yyyy-MM-dd');
}

function callGeminiApi(base64, mimeType) {
  if (!GEMINI_API_KEY) return {};
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${GEMINI_API_KEY}`;
  // プロンプトに client, participants を明示
  const prompt = `領収書画像解析。JSON出力。項目:use_date(YYYY-MM-DD),store_name,total_amount(数値),item_name,category,has_invoice(bool),client(取引先名・相手先),participants(人数または参加者名)`;
  const payload = { contents: [{ parts: [{ text: prompt }, { inline_data: { mime_type: mimeType, data: base64 } }] }] };
  try {
    const res = UrlFetchApp.fetch(url, { method: 'post', contentType: 'application/json', payload: JSON.stringify(payload), muteHttpExceptions: true });
    const json = JSON.parse(res.getContentText());
    let text = json.candidates[0].content.parts[0].text.replace(/```json|```/g, '').trim();
    return JSON.parse(text);
  } catch (e) {
    console.warn('AI Error', e);
    return {};
  }
}

function updateLearningData(item, category) {
  if(!item || !category) return;
  const sheet = getSheet(SHEETS.LEARNING);
  // 重複チェックは行わず、常に最新の対応を追記する
  sheet.appendRow([item, category, new Date()]);
}

function predictCategoryByItem(keyword) {
  const sheet = getSheet(SHEETS.LEARNING);
  if (sheet.getLastRow() < 2) return null;
  // 最後に学習されたデータからチェックするため、逆順で検索
  const data = sheet.getRange(2, 1, sheet.getLastRow()-1, 2).getValues();
  for(let i=data.length-1; i>=0; i--) if(String(data[i][0]).includes(keyword)) return data[i][1];
  return null;
}
